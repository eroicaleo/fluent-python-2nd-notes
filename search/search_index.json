{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fluent Python 2nd Edition Notes","title":"Home"},{"location":"#welcome-to-fluent-python-2nd-edition-notes","text":"","title":"Welcome to Fluent Python 2nd Edition Notes"},{"location":"ch-1/","text":"Chapter -1 Misc Notes Github link pythontutor to visualize the program. How to run doctest Example 1: \"\"\" vector2d.py: a simplistic class demonstrating some special methods It is simplistic for didactic reasons. It lacks proper error handling, especially in the ``__add__`` and ``__mul__`` methods. This example is greatly expanded later in the book. Addition:: >>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5) \"\"\" class Vector: # ... if __name__ == \"__main__\": import doctest doctest.testmod() python vector.py -v Example 2 >>> from vector import Vector >>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5) >>> v = Vector(3, 4) >>> abs(v) 5.0 >>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0 python -m doctest -v vector.doctest How to add ... if the output is too long: Reference from stackoverflow . python def foo(): \"\"\" >>> foo() # doctest: +ELLIPSIS hello ... \"\"\" print(\"hello world\") python -m doctest foo.py If we want to use ... for all the tests ```python def foo(): \"\"\" >>> foo() hello ... \"\"\" print(\"hello world\") if name == \" main \": import doctest doctest.testmod(verbose=True, optionflags=doctest.ELLIPSIS) ``` shell python foo.py -v How to catch exception? Stackover anwser . ```python c # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): NameError: name 'c' is not defined ``` How to do multiline in output when it's too long: adding +NORMALIZE_WHITESPACE >>> tshirts = [(color, size) for color in colors ... for size in sizes ] >>> tshirts # doctest: +NORMALIZE_WHITESPACE [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')] How to use verbose output doctest.testmod(verbose=True) Further Reading Chapter 1 Data model chapter . Python in a nutshell . Python Essential Reference Python Cook\u2010 book, 3rd ed. The Art of the Metaobject Protocol (Author's favorite) Cool Staff I Learned Chapter 1 The use of doctest Chapter 2 timeit module hash built-in dis.dis to check the byte code Typo Chapter 3 pg 82","title":"Chapter -1 Misc Notes"},{"location":"ch-1/#chapter-1-misc-notes","text":"Github link pythontutor to visualize the program.","title":"Chapter -1 Misc Notes"},{"location":"ch-1/#how-to-run-doctest","text":"Example 1: \"\"\" vector2d.py: a simplistic class demonstrating some special methods It is simplistic for didactic reasons. It lacks proper error handling, especially in the ``__add__`` and ``__mul__`` methods. This example is greatly expanded later in the book. Addition:: >>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5) \"\"\" class Vector: # ... if __name__ == \"__main__\": import doctest doctest.testmod() python vector.py -v Example 2 >>> from vector import Vector >>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5) >>> v = Vector(3, 4) >>> abs(v) 5.0 >>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0 python -m doctest -v vector.doctest How to add ... if the output is too long: Reference from stackoverflow . python def foo(): \"\"\" >>> foo() # doctest: +ELLIPSIS hello ... \"\"\" print(\"hello world\") python -m doctest foo.py If we want to use ... for all the tests ```python def foo(): \"\"\" >>> foo() hello ... \"\"\" print(\"hello world\") if name == \" main \": import doctest doctest.testmod(verbose=True, optionflags=doctest.ELLIPSIS) ``` shell python foo.py -v How to catch exception? Stackover anwser . ```python c # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): NameError: name 'c' is not defined ``` How to do multiline in output when it's too long: adding +NORMALIZE_WHITESPACE >>> tshirts = [(color, size) for color in colors ... for size in sizes ] >>> tshirts # doctest: +NORMALIZE_WHITESPACE [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')] How to use verbose output doctest.testmod(verbose=True)","title":"How to run doctest"},{"location":"ch-1/#further-reading","text":"","title":"Further Reading"},{"location":"ch-1/#chapter-1","text":"Data model chapter . Python in a nutshell . Python Essential Reference Python Cook\u2010 book, 3rd ed. The Art of the Metaobject Protocol (Author's favorite)","title":"Chapter 1"},{"location":"ch-1/#cool-staff-i-learned","text":"","title":"Cool Staff I Learned"},{"location":"ch-1/#chapter-1_1","text":"The use of doctest","title":"Chapter 1"},{"location":"ch-1/#chapter-2","text":"timeit module hash built-in dis.dis to check the byte code","title":"Chapter 2"},{"location":"ch-1/#typo","text":"","title":"Typo"},{"location":"ch-1/#chapter-3","text":"pg 82","title":"Chapter 3"},{"location":"ch03/","text":"Chapter 3 Dictionaries and Sets Python dicts are highly optimized\u2014and continue to get improvements. Hash tables are the engines behind Python\u2019s high-performance dicts. Modern dict Syntax dict Comprehensions Run this example: python dict_comp.py A dictcomp (dict comprehension) builds a dict instance by taking key:value pairs from any iterable. >>> dial_codes = [ ... (880, 'Bangladesh'), ... (55, 'Brazil'), ... (86, 'China'), ... (91, 'India'), ... (62, 'Indonesia'), ... (81, 'Japan'), ... (234, 'Nigeria'), ... (92, 'Pakistan'), ... (7, 'Russia'), ... (1, 'United States'), ... ] >>> country_dial = {country: code for code, country in dial_codes} >>> {code: country.upper() ... for country, code in sorted(country_dial.items()) ... if code < 70} Unpacking Mappings Run this example: python unpacking_mappings.py First, we can apply ** to more than one argument in a function call. This works when keys are all strings and unique across all arguments (because duplicate keyword arguments are forbidden): >>> def dump(**kwargs): ... return kwargs ... >>> dump(**{'x': 1}, y=2, **{'z': 3}) {'x': 1, 'y': 2, 'z': 3} Second, ** can be used inside a dict literal\u2014also multiple times and duplicate keys are allowed. Later occurrences overwrite previous ones. >>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}} {'a': 0, 'x': 4, 'y': 2, 'z': 3} Merging Mappings with | python merging_mappings.py Python 3.9 supports using | and |= to merge mappings. ''' >>> d1 = {'a': 1, 'b': 3} >>> d2 = {'a': 2, 'b': 4, 'c': 6} >>> d1|d2 {'a': 2, 'b': 4, 'c': 6} >>> d1 {'a': 1, 'b': 3} >>> d1|=d2 >>> d1 {'a': 2, 'b': 4, 'c': 6} ''' Pattern Matching with Mappings Run this example: python creator.py def get_creators(record: dict) -> list: match record: case {'type': 'book', 'api': 2, 'authors': [*names]}: # 1 return names case {'type': 'book', 'api': 1, 'author': name}: return name case {'type': 'book'}: raise ValueError(f\"Invalid 'book' record: {record!r}\") case {'type': 'movie', 'director': name}: return [name] case _: raise ValueError(f'Invalid record: {record!r}') 1 Match any mapping with 'type': 'book' , 'api': 2 , and an 'authors' key mapped to a sequence. Return the items in the sequence, as a new list. The above shows some useful practices for handling semi-structured data such as JSON records: Include a field describing the kind of record (e.g., 'type': 'movie' ) Include a field identifying the schema version (e.g., 'api': 2' ) to allow for future evolution of public APIs. Have case clauses to handle invalid records of a specific type (e.g., 'book' ), as well as a catch-all Here are the testing: ''' >>> b1 = dict(api=1, author='Douglas Hofstadter', ... type='book', title='G\u00f6del, Escher, Bach') >>> get_creators(b1) 'Douglas Hofstadter' >>> from collections import OrderedDict >>> b2 = OrderedDict(api=2, type='book', ... title='Python in a Nutshell', ... authors='Martelli Ravenscroft Holden'.split()) >>> get_creators(b2) ['Martelli', 'Ravenscroft', 'Holden'] >>> get_creators({'type': 'book', 'pages': 770}) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770} >>> get_creators('Spam, spam, spam') Traceback (most recent call last): ValueError: Invalid record: 'Spam, spam, spam' ''' Note that the order of the keys in the patterns is irrelevant, even if the subject is an OrderedDict as b2 . If we want to capture the extra key value pairs, we can use **extra . It must be the last in the pattern and **_ is forbidden. >>> food = dict(category='ice cream', flavor='vanilla', cost=199) >>> match food: ... case {'category': 'ice cream', **details}: ... print(f'Ice cream details: {details}') Ice cream details: {'flavor': 'vanilla', 'cost': 199} Standard API of Mapping Types The collections.abc module provides the Mapping and MutableMapping ABCs describing the interfaces of dict and similar types. See the following example: # python mapping-api.py >>> my_dict = {} >>> isinstance(my_dict, abc.Mapping) True >>> isinstance(my_dict, abc.MutableMapping) True To implement a custom mapping, it\u2019s easier to extend collections.UserDict , or to wrap a dict by composition, instead of subclassing these ABCs. The collections.UserDict class and all concrete mapping classes in the standard library encapsulate the basic dict in their implementation, which in turn is built on a hash table. What Is Hashable An object is hashable if it has a hash code which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash code. Numeric types Flat immutable types str and bytes Container types are hashable if they are immutable and all contained objects are also hashable. A frozenset is always hashable, because every element it contains must be hashable. See ch03/hash-test.py >>> tt = (1, 2, (30, 40)) >>> hash(tt) -3907003130834322577 >>> tl = (1, 2, [30, 40]) >>> hash(tl) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): TypeError: unhashable type: 'list' >>> tf = (1, 2, frozenset([30, 40])) >>> hash(tf) 5149391500123939311 The hash code of an object may be different depending on: version of Python the machine architecture a salt added to the hash computation for security reasons The hash code of a correctly implemented object is guaranteed to be constant only within one Python process.","title":"Chapter 03 Dictionaries and Sets"},{"location":"ch03/#chapter-3-dictionaries-and-sets","text":"Python dicts are highly optimized\u2014and continue to get improvements. Hash tables are the engines behind Python\u2019s high-performance dicts.","title":"Chapter 3 Dictionaries and Sets"},{"location":"ch03/#modern-dict-syntax","text":"","title":"Modern dict Syntax"},{"location":"ch03/#dict-comprehensions","text":"Run this example: python dict_comp.py A dictcomp (dict comprehension) builds a dict instance by taking key:value pairs from any iterable. >>> dial_codes = [ ... (880, 'Bangladesh'), ... (55, 'Brazil'), ... (86, 'China'), ... (91, 'India'), ... (62, 'Indonesia'), ... (81, 'Japan'), ... (234, 'Nigeria'), ... (92, 'Pakistan'), ... (7, 'Russia'), ... (1, 'United States'), ... ] >>> country_dial = {country: code for code, country in dial_codes} >>> {code: country.upper() ... for country, code in sorted(country_dial.items()) ... if code < 70}","title":"dict Comprehensions"},{"location":"ch03/#unpacking-mappings","text":"Run this example: python unpacking_mappings.py First, we can apply ** to more than one argument in a function call. This works when keys are all strings and unique across all arguments (because duplicate keyword arguments are forbidden): >>> def dump(**kwargs): ... return kwargs ... >>> dump(**{'x': 1}, y=2, **{'z': 3}) {'x': 1, 'y': 2, 'z': 3} Second, ** can be used inside a dict literal\u2014also multiple times and duplicate keys are allowed. Later occurrences overwrite previous ones. >>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}} {'a': 0, 'x': 4, 'y': 2, 'z': 3}","title":"Unpacking Mappings"},{"location":"ch03/#merging-mappings-with","text":"python merging_mappings.py Python 3.9 supports using | and |= to merge mappings. ''' >>> d1 = {'a': 1, 'b': 3} >>> d2 = {'a': 2, 'b': 4, 'c': 6} >>> d1|d2 {'a': 2, 'b': 4, 'c': 6} >>> d1 {'a': 1, 'b': 3} >>> d1|=d2 >>> d1 {'a': 2, 'b': 4, 'c': 6} '''","title":"Merging Mappings with |"},{"location":"ch03/#pattern-matching-with-mappings","text":"Run this example: python creator.py def get_creators(record: dict) -> list: match record: case {'type': 'book', 'api': 2, 'authors': [*names]}: # 1 return names case {'type': 'book', 'api': 1, 'author': name}: return name case {'type': 'book'}: raise ValueError(f\"Invalid 'book' record: {record!r}\") case {'type': 'movie', 'director': name}: return [name] case _: raise ValueError(f'Invalid record: {record!r}') 1 Match any mapping with 'type': 'book' , 'api': 2 , and an 'authors' key mapped to a sequence. Return the items in the sequence, as a new list. The above shows some useful practices for handling semi-structured data such as JSON records: Include a field describing the kind of record (e.g., 'type': 'movie' ) Include a field identifying the schema version (e.g., 'api': 2' ) to allow for future evolution of public APIs. Have case clauses to handle invalid records of a specific type (e.g., 'book' ), as well as a catch-all Here are the testing: ''' >>> b1 = dict(api=1, author='Douglas Hofstadter', ... type='book', title='G\u00f6del, Escher, Bach') >>> get_creators(b1) 'Douglas Hofstadter' >>> from collections import OrderedDict >>> b2 = OrderedDict(api=2, type='book', ... title='Python in a Nutshell', ... authors='Martelli Ravenscroft Holden'.split()) >>> get_creators(b2) ['Martelli', 'Ravenscroft', 'Holden'] >>> get_creators({'type': 'book', 'pages': 770}) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770} >>> get_creators('Spam, spam, spam') Traceback (most recent call last): ValueError: Invalid record: 'Spam, spam, spam' ''' Note that the order of the keys in the patterns is irrelevant, even if the subject is an OrderedDict as b2 . If we want to capture the extra key value pairs, we can use **extra . It must be the last in the pattern and **_ is forbidden. >>> food = dict(category='ice cream', flavor='vanilla', cost=199) >>> match food: ... case {'category': 'ice cream', **details}: ... print(f'Ice cream details: {details}') Ice cream details: {'flavor': 'vanilla', 'cost': 199}","title":"Pattern Matching with Mappings"},{"location":"ch03/#standard-api-of-mapping-types","text":"The collections.abc module provides the Mapping and MutableMapping ABCs describing the interfaces of dict and similar types. See the following example: # python mapping-api.py >>> my_dict = {} >>> isinstance(my_dict, abc.Mapping) True >>> isinstance(my_dict, abc.MutableMapping) True To implement a custom mapping, it\u2019s easier to extend collections.UserDict , or to wrap a dict by composition, instead of subclassing these ABCs. The collections.UserDict class and all concrete mapping classes in the standard library encapsulate the basic dict in their implementation, which in turn is built on a hash table.","title":"Standard API of Mapping Types"},{"location":"ch03/#what-is-hashable","text":"An object is hashable if it has a hash code which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash code. Numeric types Flat immutable types str and bytes Container types are hashable if they are immutable and all contained objects are also hashable. A frozenset is always hashable, because every element it contains must be hashable. See ch03/hash-test.py >>> tt = (1, 2, (30, 40)) >>> hash(tt) -3907003130834322577 >>> tl = (1, 2, [30, 40]) >>> hash(tl) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): TypeError: unhashable type: 'list' >>> tf = (1, 2, frozenset([30, 40])) >>> hash(tf) 5149391500123939311 The hash code of an object may be different depending on: version of Python the machine architecture a salt added to the hash computation for security reasons The hash code of a correctly implemented object is guaranteed to be constant only within one Python process.","title":"What Is Hashable"}]}